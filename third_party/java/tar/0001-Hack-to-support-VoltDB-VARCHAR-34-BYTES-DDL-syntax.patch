From dde14db81b68681e8ecd16b3165a74046774e8a9 Mon Sep 17 00:00:00 2001
From: Lukai Liu <lliu@voltdb.com>
Date: Thu, 27 Sep 2018 11:05:57 -0400
Subject: [PATCH] Hack to support VoltDB "VARCHAR(34 BYTES)" DDL syntax

---
 core/src/main/codegen/templates/Parser.jj        | 11 ++++++++++-
 .../org/apache/calcite/sql/SqlDataTypeSpec.java  | 16 ++++++++++++++--
 2 files changed, 24 insertions(+), 3 deletions(-)

diff --git a/core/src/main/codegen/templates/Parser.jj b/core/src/main/codegen/templates/Parser.jj
index c1df4cbc1..f30e22509 100644
--- a/core/src/main/codegen/templates/Parser.jj
+++ b/core/src/main/codegen/templates/Parser.jj
@@ -3676,103 +3676,111 @@ int IntLiteral() :
 {
     Token t;
 }
 {
     ( t = <UNSIGNED_INTEGER_LITERAL> | <PLUS> t = <UNSIGNED_INTEGER_LITERAL> )
     {
         try {
             return Integer.parseInt(t.image);
         } catch (NumberFormatException ex) {
             throw generateParseException();
         }
     }
     |
     <MINUS> t = <UNSIGNED_INTEGER_LITERAL>
     {
         try {
             return -Integer.parseInt(t.image);
         } catch (NumberFormatException ex) {
             throw generateParseException();
         }
     }
 }
 
 // Type name with optional scale and precision
 SqlDataTypeSpec DataType() :
 {
     SqlIdentifier typeName;
     SqlIdentifier collectionTypeName = null;
     int scale = -1;
     int precision = -1;
+    boolean inBytes = false;
     String charSetName = null;
     SqlParserPos pos;
 }
 {
     (
         typeName = TypeName()
         {
             pos = getPos();
         }
         [
             <LPAREN>
             precision = UnsignedIntLiteral()
             [
                 <COMMA>
                 scale = UnsignedIntLiteral()
             ]
+            [
+               <BYTES>
+               {
+                  inBytes = true;
+               }
+            ]
             <RPAREN>
         ]
         [
             <CHARACTER> <SET>
             charSetName = Identifier()
         ]
         [
             collectionTypeName = CollectionsTypeName()
         ]
     )
     {
         if (null != collectionTypeName) {
             return new SqlDataTypeSpec(
                 collectionTypeName,
                 typeName,
                 precision,
                 scale,
                 charSetName,
                 pos);
         }
         return new SqlDataTypeSpec(
             typeName,
             precision,
             scale,
             charSetName,
             null,
-            pos);
+            pos)
+        .setInBytes(inBytes);
     }
 }
 
 // Some SQL type names need special handling due to the fact that they have
 // spaces in them but are not quoted.
 SqlIdentifier TypeName() :
 {
     SqlIdentifier typeName = null;
     SqlParserPos pos = getPos();
 }
 {
     (
         (<CHARACTER> | <CHAR>)
         {
             typeName = new SqlIdentifier(
                 SqlTypeName.CHAR.name(), pos);
         }
         [
             <VARYING>
             {
                 typeName = new SqlIdentifier(
                     SqlTypeName.VARCHAR.name(), pos);
             }
         ]
         | <VARCHAR>
         {
             typeName = new SqlIdentifier(
                 SqlTypeName.VARCHAR.name(), pos);
         }
         | <DATE>
@@ -4733,60 +4741,61 @@ SqlPostfixOperator PostfixRowOperator() :
     | < ALWAYS: "ALWAYS" >
     | < ALTER: "ALTER" >
     | < AND: "AND" >
     | < ANY: "ANY" >
     | < ARE: "ARE" >
     | < ARRAY: "ARRAY" >
     | < AS: "AS" >
     | < ASC: "ASC" >
     | < ASENSITIVE: "ASENSITIVE" >
     | < ASSERTION: "ASSERTION" >
     | < ASSIGNMENT: "ASSIGNMENT" >
     | < ASYMMETRIC: "ASYMMETRIC" >
     | < AT: "AT" >
     | < ATOMIC: "ATOMIC" >
     | < ATTRIBUTE: "ATTRIBUTE" >
     | < ATTRIBUTES: "ATTRIBUTES" >
     | < AUTHORIZATION: "AUTHORIZATION" >
     | < AVG: "AVG" >
     | < BEFORE: "BEFORE" >
     | < BEGIN: "BEGIN" >
     | < BERNOULLI: "BERNOULLI" >
     | < BETWEEN: "BETWEEN" >
     | < BIGINT: "BIGINT" >
     | < BINARY: "BINARY" >
     | < BIT: "BIT" >
     | < BLOB: "BLOB" >
     | < BOOLEAN: "BOOLEAN" >
     | < BOTH: "BOTH" >
     | < BREADTH: "BREADTH" >
     | < BY: "BY" >
+    | < BYTES: "BYTES" >
     | < C: "C" >
     | < CALL: "CALL" >
     | < CALLED: "CALLED" >
     | < CARDINALITY: "CARDINALITY" >
     | < CASCADE: "CASCADE" >
     | < CASCADED: "CASCADED" >
     | < CASE: "CASE" >
     | < CAST: "CAST" >
     | < CATALOG: "CATALOG" >
     | < CATALOG_NAME: "CATALOG_NAME" >
     | < CEIL: "CEIL" >
     | < CEILING: "CEILING" >
     | < CHAIN: "CHAIN" >
     | < CHAR: "CHAR" >
     | < CHAR_LENGTH: "CHAR_LENGTH" >
     | < CHARACTER: "CHARACTER" >
     | < CHARACTER_LENGTH: "CHARACTER_LENGTH" >
     | < CHARACTER_SET_CATALOG: "CHARACTER_SET_CATALOG" >
     | < CHARACTER_SET_NAME: "CHARACTER_SET_NAME" >
     | < CHARACTER_SET_SCHEMA: "CHARACTER_SET_SCHEMA" >
     | < CHARACTERISTICS: "CHARACTERISTICTS" >
     | < CHARACTERS: "CHARACTERS" >
     | < CHECK: "CHECK" >
     | < CLASS_ORIGIN: "CLASS_ORIGIN" >
     | < CLOB: "CLOB" >
     | < CLOSE: "CLOSE" >
     | < COALESCE: "COALESCE" >
     | < COBOL: "COBOL" >
     | < COLLATE: "COLLATE" >
     | < COLLATION: "COLLATION" >
diff --git a/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java b/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
index d4bfc6cba..51c615b9d 100644
--- a/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
+++ b/core/src/main/java/org/apache/calcite/sql/SqlDataTypeSpec.java
@@ -33,60 +33,61 @@
 import java.util.Objects;
 import java.util.TimeZone;
 
 import static org.apache.calcite.util.Static.RESOURCE;
 
 /**
  * Represents a SQL data type specification in a parse tree.
  *
  * <p>A <code>SqlDataTypeSpec</code> is immutable; once created, you cannot
  * change any of the fields.</p>
  *
  * <p>todo: This should really be a subtype of {@link SqlCall}.</p>
  *
  * <p>In its full glory, we will have to support complex type expressions
  * like:</p>
  *
  * <blockquote><code>ROW(<br>
  *   NUMBER(5, 2) NOT NULL AS foo,<br>
  *   ROW(BOOLEAN AS b, MyUDT NOT NULL AS i) AS rec)</code></blockquote>
  *
  * <p>Currently it only supports simple datatypes like CHAR, VARCHAR and DOUBLE,
  * with optional precision and scale.</p>
  */
 public class SqlDataTypeSpec extends SqlNode {
   //~ Instance fields --------------------------------------------------------
 
   private final SqlIdentifier collectionsTypeName;
   private final SqlIdentifier typeName;
   private final int scale;
   private final int precision;
+  private boolean inBytes = false;
   private final String charSetName;
   private final TimeZone timeZone;
 
   /** Whether data type is allows nulls.
    *
    * <p>Nullable is nullable! Null means "not specified". E.g.
    * {@code CAST(x AS INTEGER)} preserves has the same nullability as {@code x}.
    */
   private Boolean nullable;
 
   //~ Constructors -----------------------------------------------------------
 
   /**
    * Creates a type specification representing a regular, non-collection type.
    */
   public SqlDataTypeSpec(
       final SqlIdentifier typeName,
       int precision,
       int scale,
       String charSetName,
       TimeZone timeZone,
       SqlParserPos pos) {
     this(null, typeName, precision, scale, charSetName, timeZone, null, pos);
   }
 
   /**
    * Creates a type specification representing a collection type.
    */
   public SqlDataTypeSpec(
       SqlIdentifier collectionsTypeName,
@@ -132,84 +133,95 @@ public SqlNode clone(SqlParserPos pos) {
   }
 
   public SqlMonotonicity getMonotonicity(SqlValidatorScope scope) {
     return SqlMonotonicity.CONSTANT;
   }
 
   public SqlIdentifier getCollectionsTypeName() {
     return collectionsTypeName;
   }
 
   public SqlIdentifier getTypeName() {
     return typeName;
   }
 
   public int getScale() {
     return scale;
   }
 
   public int getPrecision() {
     return precision;
   }
 
   public String getCharSetName() {
     return charSetName;
   }
 
   public TimeZone getTimeZone() {
     return timeZone;
   }
 
+  public boolean getInBytes() {
+    return inBytes;
+  }
+
+  public SqlDataTypeSpec setInBytes(boolean inBytes) {
+    this.inBytes = inBytes;
+    return this;
+  }
+
   /** Returns a copy of this data type specification with a given
    * nullability. */
   public SqlDataTypeSpec withNullable(Boolean nullable) {
     if (SqlFunctions.eq(nullable, this.nullable)) {
       return this;
     }
     return new SqlDataTypeSpec(collectionsTypeName, typeName, precision, scale,
-        charSetName, timeZone, nullable, getParserPosition());
+        charSetName, timeZone, nullable, getParserPosition())
+       .setInBytes(inBytes);
   }
 
   /**
    * Returns a new SqlDataTypeSpec corresponding to the component type if the
    * type spec is a collections type spec.<br>
    * Collection types are <code>ARRAY</code> and <code>MULTISET</code>.
    */
   public SqlDataTypeSpec getComponentTypeSpec() {
     assert getCollectionsTypeName() != null;
     return new SqlDataTypeSpec(
         typeName,
         precision,
         scale,
         charSetName,
         timeZone,
-        getParserPosition());
+        getParserPosition())
+       .setInBytes(inBytes);
   }
 
   public void unparse(
       SqlWriter writer,
       int leftPrec,
       int rightPrec) {
     String name = typeName.getSimple();
     if (SqlTypeName.get(name) != null) {
       SqlTypeName sqlTypeName = SqlTypeName.get(name);
 
       // we have a built-in data type
       writer.keyword(name);
 
       if (sqlTypeName.allowsPrec() && (precision >= 0)) {
         final SqlWriter.Frame frame =
             writer.startList(SqlWriter.FrameTypeEnum.FUN_CALL, "(", ")");
         writer.print(precision);
         if (sqlTypeName.allowsScale() && (scale >= 0)) {
           writer.sep(",", true);
           writer.print(scale);
         }
         writer.endList(frame);
       }
 
       if (charSetName != null) {
         writer.keyword("CHARACTER SET");
         writer.identifier(charSetName);
       }
 
       if (collectionsTypeName != null) {
-- 
2.17.1

